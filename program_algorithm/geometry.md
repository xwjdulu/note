q223 850
两个矩形的重叠面积：在xy轴的映射：(x1,x2),(y1,y2)   (x3,x4),(y3,y4)
只有 overlapx =  min(x2,x4) - max(x1,x3)
     overlapy = min(y2,y4) - max(y1,y3)
只有两者都存在，才有重叠
q391 扫描线
q827  求满足条件的块，再遍历，假使其翻转

二维数组旋转：1，划分为块  2，翻转：swap
二维数组的四个方向：vector<vector<int>>(4,vector<int>(2));
bfs与queue

q895:
频率栈：按频率从大到小出栈：
为每个频率都建栈，同时维护最大频率maxfq，从vc[maxfq]出栈
除了map，set，c++自带容器嵌套

q2049 1,dfs时，注意分成的三部分合起来是n，由整体减求的推出剩余
2，树中一定存在着parent数组  3，不要把long 赋值给int，不报错还错误赋值
q310，确定起点后，更新parent数组，以此回溯路径

q84 用单调栈求解两侧更小的数，这就说明栈顶比当前数小，是递增栈，
在从左遍历时也可以求出右边位置更小于等于的数（出栈时当前数是第一个比栈里面小于等于的数）
虽然右边数组记录的不是右边第一个比当前数小的数，但当栈里面两个数相等时，它们构造成同一个矩形，
右边的那个数记录对的右边更小数

q85  先说错误思路：(i,j)作为右下点能组成的矩形边长不能由(i-1,j)和(i,j-1)推出，比如(i,j)为1，左上两
点都为0，min（左长+1，上长）是0不是1，min（左高，上高+1）是0不是1
正确思路，记录每个点连续左长，朴素法：枚举每个点和它上方的点，维护宽度再乘高，o(m*n*m)
单调栈：每一列的连续左长相当于q84：求数组的高度能得出的最大矩形

q1594:有正有负就分类最大值最小值，正数乘大得最大，乘小得最小
随想：一个连续子路径的思想：判断当前位置该接上还是另作起点


