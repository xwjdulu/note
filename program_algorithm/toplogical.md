
q1584 最小生成树：克鲁斯卡尔算法，普利姆算法 最小生成树
q2471  数组排序的最小交换次数错误思路：记录每个人的正确位置，然后遍历，若不在正确位置上，则放入正确位置
错误理由：当n个数都形成一个环，应该交换n-1次，但是遇到不是正确位置得数把它放入后方正确的位置，后续遍历
到该数时，计数变少
正确做法：长度减环数
见q765：for(int i = 0;i<n/2;i++){
            if(i == find(i))
                c++;
        }
c代表计算有几个环：本来i对情侣的father就是i，经过并集操作后，father改变了，由此得环数

q684  图连接问题：并查集 q839:判断是否同一集合：看父节点是否相同 判断是否已连接：cnc函数（如果没链接，则会连接）

q329:不能用单纯的动态规划，因为一个点的值可能来自左上点，而前点的值又可能来自右下
没有确定方向，只能dfs 或者；转化为拓扑结构（一定无环）：相连的且有比它大的则有出度，枚举所有出度为0的点的最长路径bfs


q6330：数据量不能用floyd法，也不能像2360用dfs时间戳法：因为从一个点到目标点会有多个路径，产生多个时间戳
用bfs法求得从一个点x到邻接两点的路长，但x可能前面有其它点，比如：[0,1],[1,2],[1,3],[2,3]，但根据n<=1000
可以o(n^2),即遍历每个点为起点，心急吃不了热豆腐啊！！！注意先处理再入队，bfs前先初始化

q269：判断拓扑结构是否有环
1，相邻单词第一个不同代表拓扑顺序
2，要把所有出现的单词都放入答案，不用vector<vector<int>>nxt,
用unordered_map<char,vector,int>>nxt表示出现了哪些单词
3用dfs时，在return前添加char进res，越早return，越是最低级
4用bfs，不断更新入度表，入度为0则加入res，是高优先级

q2617,2612:把几何问题转化成拓扑问题，从出发点(2612:p)(2617:0,0)bfs到其余点的最短距离
去重：一个点有很多相邻点，而我们只想要访问一个点一次，采用set，不断插入bfs的queue和从set删除
unordered_set<int>ban = {banned.begin(),banned.end()};
q.push({0,0});
auto &s = st[l%2];
for(auto it = s.lower_bound(l);it != s.end() && *it<=r;it = s.erase(it))





