socket三个参数：

domain 套接字中使用的协议族( Protocol Famjly )信息,ipv4,ipv6

type 套接字数据传输类型信息

protocol 计算机间通信中使用的协议信息
***
#套接字类型：

1：面向连接（a:传输不丢失；b:按序传输；c：数据传输以流形式，无边界）

2：面向消息（a：快；b：丢失可能；c：数据传输有边界；d：限制传输大小）
***
前面已经通过socket函数的前两个参数传递了协议族信息和套接字数据传输方式，这些信息还不足以决定采用的协议吗?为什么还需要传递第3个参数呢?

正如各位所想，传递前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递0，除非遇到以下这种情况:

“同一协议族中存在多个数据传输方式相同的协议”
***
连接型套接字TCP套接字是没有数据边界的。因此，调用输入/输出函数的次数是没有意义的。重要的是函数调用次数而不是数据传输量。因此，必须编写代码:确保发送数据量与接收数据量相匹配，特别是不应编写依赖于函数调用次数的代码。
***
tcp_server.c和tcp_client.c中需多次调用read函数读取以下字符串:服务器端调用1次write函数传递的字符串。

更改程序，使服务器端多次调用（次数自拟) write函数传输数据，客户端调用1次read函数进行读取。为达到这一目的，客户端需延迟调用read函数，因为客户端要等待服务器端传输所有数据。Windows和Linux都通过下列代码延迟read或recv函数的调用。
```
for(i=e; i<300e; i++)
    printf("wait time %d \n"， i);
```
让CPU执行多余任务以延迟代码运行的方式称为“Busy Waiting”。使用得当即可推迟函数调用。

繁忙等待（Busy Waiting），也称为自旋锁（Spin Lock），是一种并发编程中的一种技术或方法。它通常用于在多线程或多进程环境中实现临界区（Critical Section）的同步。

在繁忙等待中，一个线程或进程会反复检查某个条件是否满足，而不是通过进入休眠状态来等待条件的满足。这个线程会“自旋”在一个循环中，不断地检查条件，直到条件满足为止。一旦条件满足，线程就可以继续执行临界区的代码。

