TCP 和 UDP 的区别
tcp是面向连接安全的传输协议，udp是无连接不安全的传输协议，tcp有连接时三次握手，断开时四次挥手，udp没有，tcp能够保证通信双方首发信息的完整性，udp无法保证通信双方首发信息的完整性。tcp只支持点对点的传输，udp支持一对一，一对多，多对多的传输
udp几乎没有做什么特别的事情。面向连接的是 TCP，该协议几乎做了所有的事情,所以TCP的首部开销大，占用20字节；而UDP的首部开销小，只占用8个字节 
TCP的使用场景是不在意传输数据速度，但在意传输数据准确；而UDP的使用场景则是对实时性要求较高，而UDP即使在网络拥塞的时候，传输速度也不会慢

TCP 三次握手四次挥手过程synchronize，acknowledge，finish
TCP的三次握手： 首先客户端发送一个含有同步序列号SYN的标志位的数据段给服务器端。服务器端收到客户端的请求后发送确认请求ACK和同步序列号SYN。最后客户端发送一个确认应答后连接开始建立。 TCP的四次挥手： 客户端发送一个控制位FIN为1的数据段，提出结束TCP连接的请求。 服务器端收到请求后确认这一端的TCP连接将断开，将ACK置为1。 服务器端反过来对客户端发送关闭请求，将FIN置为1。 客户端收到请求确认关闭这一端的TCP连接，将ACK置为1。

GET 和 POST 的区别
GET方法是向服务器请求数据的，而POST方法是向服务器上传数据的。 GET方法是显式传参，可以直接在url上看到参数，POST是隐式传参，无法直接看到参数。 GET有长度限制2KB，而一般默认POST没有限制。

进程通信的方式
同一个进程中的线程共享数据空间可以直接通信，但是进程间是无法直接进行通信的
管道模型:
竖线|，在linux中是作为管道符的，将|前面命令的输出作为|后面的输入

消息队列模型:队列模式也可以有多个生产者消费者，但是同一个消息只能被一个消费者消费，为了解决这个为题，演化出了另一种消息模型发布 - 订阅模型（Publish-Subscribe Pattern）也被称为主题模型。

共享内存：多用于传输一些大文件，如果采用管道或者消息队列传输大文件，涉及到重复拷贝，比较消耗性能，因此模拟多线程，在内存中开辟一块特殊的内存用于多个进程共享访问。也是进程间最高效的通信方式。进程通过调用shmget（Shared Memory GET，获取共享内存）来分配一个共享内存块。 shmat（SHared Memory Attach，绑定到共享内存），shmctl（"Shared Memory Control"，控制共享内存）函数会返回一个共享内存块的相关信息。

信号量机制：0表示当前已没有空闲资源，而正数表示当前空闲资源的数量，负数的绝对值表示正在等待进入临界区的进程个数
P原语为阻塞原语，负责把当前进程由运行状态转换为阻塞状态，直到另外一个进程唤醒它。操作为：申请一个空闲资源（把信号量减1），若成功，则退出；若失败，则该进程被阻塞；
V原语负责把一个被阻塞的进程唤醒，它有一个参数表，存放着等待被唤醒的进程信息。操作为：释放一个被占用的资源（把信号量加1），如果发现有被阻塞的进程，则选择一个唤醒之。

socket：服务端创建套接字，绑定ip端口，监听端口号，等待客户端调用，客户端创建之后与服务端TCP三次握手建立连接完成，双方就可以发送和接收数据。
表示方法：套接字Socket=（IP地址：端口号）

PCB Process Control Block
1.进程是操作系统进行资源调度和分配的基本单位,线程是操作系统可执行的最小调度和分配单位 2.一个线程属于一个进程,一个进程可以有多个线程 3.一个进程崩溃不影响其他进程,但是一个线程崩溃会让进程崩溃 4.进程在执行过程中有独立的存储单元,而线程之间共享进程的内存 
5.进程之间切换系统开销大,而线程（复刻（英语：fork，又译作派生、分支）是UNIX或类UNIX中的分叉函数）之间切换开销比进程小

File Discriptor 中文翻译为文件描述符
io复用：为了实现一个服务器可以支持多个客户端，连接一个连接来了，就必须遍历所有已经注册的文件描述符，来找到那个需要处理信息的文件描述符，如果已经注册了几万个文件描述符，那会因为遍历这些已经注册的文件描述符，导致cpu爆炸。

epoll 的使用非常简单，只有下面 3 个系统调用epoll_create，epollctl，epollwait
epollcreate 负责创建一个池子，一个监控和管理句柄 fd 的池子；
epollctl 负责管理这个池子里的 fd 增、删、改；
epollwait 就是负责打盹的，让出 CPU 调度，但是只要有“事”，立马会从这里唤醒
红黑树：是一种平衡二叉树，时间复杂度为 O(log n)，池子就算不断对fd增删改
epoll 池核心的两个数据结构：红黑树和就绪列表。红黑树是为了应对用户的增删改需求，就绪列表是 fd 事件就绪之后放置的特殊地点，epoll 池只需要遍历这个就绪链表，就能给用户返回所有已经就绪的 fd 数组；

同步：执行一个操作之后，等待结果，然后才继续执行后续的操作。
异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作
阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。
非阻塞：进程给CPU传达任务后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。这样的过程其实也叫轮询

浏览器从输入 URL 开始到页面显示内容
1.DNS解析域名，获取ip端口（从本地/根/顶级服务器依次查询） 2.建立tcp链接 3.http发送请求 4.服务器处理请求 5.服务器端返回数据 6.关闭tcp链接 7.浏览器解析html 8.浏览器布局渲染

HTTP 状态码及其含义
1**	信息，服务器收到请求，需要请求者继续执行操作
2**	成功，操作被成功接收并处理
3**	重定向，需要进一步的操作以完成请求
4**	客户端错误，请求包含语法错误或无法完成请求
5**	服务器错误，服务器在处理请求的过程中发生了错误

cd 切换当前目录 ls 查看当前路径下的文件和文件夹 mv 移动文件和文件夹 rm 删除文件和文件夹 cp 复制文件和文件夹 
ps 查看当前进程 kill 向进程发送信号 pwd 显示当前工作目录 cat 查看文件内容 top 查看操作系统信息 free 查看内存使用情况
ps aux查看所有的进程

SSL/TLS是位于传输层与应用层之间的加密协议（属于Socket层实现），对于应用层来说是透明的，应用层数据通过传递给SSL层进行加密，并增加SSL头，再传递给传输层。
http是超文本传输协议，是明文传输的，https是安全的加密传输的，由ssl/tls+http组成，端口号不同，http是80，https是443

唯一指针：就是指对象的所有权唯一，相对于auto_ptr其能在编译期间禁止拷贝操作，更加安全。 共享指针：有引用计数的功能，能自动销毁防止内存泄漏。但是会存在循环引用的问题。 弱指针：可以用来查看共享指针的状态，解决其循环引用的问题。

TIME_WT
四次挥手结束，主动方进入TIME_WT状态。 标准回答 TCP连接第四次挥手结束时，主动发起连接释放请求的一方进入TIME_WT状态，此时主动发起连接释放请求的一方会等待2MSL（最大报文生存期）才会回到初始状态CLOSED。
当主动发起连接释放请求的一方最后发送ACK确认数据包在网络中丢失时，由于TCP的重传机制，被动关闭的一方会重新发送FIN，在FIN到达主动关闭的一方之前，主动关闭的一方需要维持这条连接，也就是主动的一方TCP资源不可以释放，直到被动关闭一方的FIN到达之后，主动关闭方重新发送ACK确认数据包，经过2MSL时间周期没有再收到被动关闭一方的FIN之后，才会恢复到CLOSED状态
1、全双工连接能够可靠断开；2、等待网络中游离的报文消散

CLOSE_WT
自身给予响应ACK确认应答，但是TCP连接是全双工的，也需要自身发送连接释放请求，即FIN。但是自身并没有立即发送FIN，进入CLOSE_WT状态。
TCP四次挥手时，对于服务端来说，客户端先发送断开请求，服务端给予回应，此时服务端进入CLOSE_WAIT状态，此时服务端知道客户端的请求结束了，但是服务端如果还有数据发送，依然可以发送给客户端，因为TCP连接是全双工的

线程和协程的区别
线程是操作系统的资源，线程的创建、切换、停止等都非常消耗资源，而创建协程不需要调用操作系统的功能，编程语言自身就能完成，所以协程也被称为用户态线程，协程比线程轻量很多；
线程在多核环境下是能做到真正意义上的并行，而协程是为并发而产生的
线程进程都是同步机制，而协程则是异步

TCP/IP 五层模型
应用层、运输层、网络层、数据链路层、物理层
1,不同的应用程序都需要不同的应用层协议
2,通用是指不会针对特定的应用层协议进行详细的划分，多种应用层协议公用同一个运输层服务，所以运输层有复用的功能
3,提供通信服务,网络层使用IP协议
4,链路层将网络层交下来的数据报组装成帧
5,数据的传输都是通过0（或1）比特流来实现的

Address Resolution Protocol 是根据IP地址获取物理地址的一个TCP/IP协议
主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源
建立在网络中各个主机互相信任的基础上，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗



