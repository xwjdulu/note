面向对象的三大特性：
封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。
继承：子类继承父类的特征和行为，子类有父类的非private方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被final关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。
多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。

final:        class B: public A13 {};
B 继承A ，编译以及运行都正常。如果我们现在把第三行修改为class A13 final {};  加在类名后，不能被继承

隐藏：是指派生类的函数屏蔽了与其同名的基类函数，只要是同名函数，不管参数列表是否相同，基类函数都会被隐藏。

重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。
多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。

虚函数：被 virtual 关键字修饰的成员函数，就是虚函数。  纯虚函数在类中声明时，加上 = 0；
含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；
继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。
子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。

虚函数和纯虚函数的区别
虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；

虚函数通过虚函数表来实现。
虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。
虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。

默认构造函数：是无参调用的构造函数，包括两种：没有参数，每个参数有初始值

构造函数一般不定义为虚函数：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。
析构函数一般定义成虚函数：析构函数定义成虚函数是为了防止内存泄漏。因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数

在构造函数中使用类初始化列表，会减少调用默认的构造函数产生的开销。(少调用默认构造函数)
用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。

浅拷贝和深拷贝的区别：
拷贝只是对浅指针的拷贝，拷贝后两个指针指向同一个内存空间。深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。
为什么拷贝构造函数必须为引用？
原因：避免拷贝构造函数无限制的递归，最终导致栈溢出

构造函数调用顺序：
按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数；
按照派生类中成员变量的声名顺序，依次调用派生类中成员变量所属类的构造函数；
执行派生类自身的构造函数。


#include <iostream>
using namespace std;
 
class A{
public:
    A() { cout << "A()" << endl; }
    ~A() { cout << "~A()" << endl; }
};
 
class B{
public:
    B() { cout << "B()" << endl; }
    ~B() { cout << "~B()" << endl; }
};
 
class Test : public A, public B // 派生列表
{
public:
    Test() { cout << "Test()" << endl; }
    ~Test() { cout << "~Test()" << endl; }
 
private:
    B ex1;
    A ex2;
};
 
int main(){
    Test ex;
    return 0;
}
/*
运行结果：
A()
B()
B()
A()
Test()
~Test()
~A()
~B()
~B()
~A()
*/
首先调用基类 A 和 B 的构造函数，按照派生列表 public A, public B 的顺序构造；
然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造；
最后调用派生类的构造函数；接下来调用析构函数，和构造函数调用的顺序相反

如何禁止一个类被实例化，在类中定义一个纯虚函数，使该类成为抽象基类

省去默认构造函数
#include <iostream>
using namespace std;
class A{
private:
    int val;
public:
    A(){
        cout << "A()" << endl;
    }
    A(int tmp){
        val = tmp;
        cout << "A(int " << val << ")" << endl;
    }
};
class Test1{
private:
    A ex;
public:
    Test1() : ex(1) // 成员列表初始化方式
    {
    }
}; 
class Test2{
private:
    A ex;
 
public:
    Test2() // 函数体中赋值的方式
    {
        ex = A(2);
    }
};
int main(){
    Test1 ex1;
    cout << endl;
    Test2 ex2;
    return 0;
}
/*
运行结果：
A(int 1)
A()
A(int 2)


