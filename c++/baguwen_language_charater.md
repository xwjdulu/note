指针和引用的异同点
引用是别名，而指针是地址
由于硬件通过地址访问内存位置，因此引用可以理解为一个常量指针，只能绑定到初始化它的对象上

malloc的底层实现

开辟空间小于128K时，通过brk()函数
将数据段.data的最高地址指针_edata向高地址移动，即增加堆的有效区域来申请内存空间
brk分配的内存需要等到高地址内存释放以后才能释放，这也是内存碎片产生的原因

开辟空间大于128K时，通过mmap()函数
利用mmap系统调用，在堆和栈之间文件映射区域申请一块虚拟内存
128K限制可由M_MMAP_THRESHOLD选项进行修改
mmap分配的内存可以单独释放

struct、union的异同
union:一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，
以达到节省空间的目的。union变量所占用的内存长度等于最长的成员的内存长度。
struct中每个变量依次存储；union中，每个变量都是从偏移地址零开始存储，同一时刻只有一个成员存储于该地址
struct内存大小遵循结构对齐原则
数据成员对齐规则：每个数据成员存储的起始位置要从该成员大小的整数倍开始
数据成员包含结构体：结构体成员要从其内部最大元素对象的整数倍地址开始存储
结构体总大小：其内部最大基本成员的整数倍，不足则要补齐

extern C的作用
C语言不支持函数重载，即不允许同名符号，所以不需要这些工作，因此在C++代码中加入extern C，是为了链接规范
在C++源文件中的语句前面加上extern "C"，表明它按照类C的编译和连接规约来编译和连接，而不是C++的编译的连接规约

机器大小端问题
大端指数据的高字节保存在内存的低地址中，数据的低字节保存在内存的高地址中；小端与此相反

volatile的用法
编译器不会对volatile变量有关的运算进行编译优化：每次使用该变量必须从内存地址中读取，而不是保存在寄存器中的备份
用到volatile的几种情况
并行设备的硬件寄存器（如状态寄存器）
中断服务子程序会访问到的非自动变量
多线程应用中被几个任务共享的变量

数组名和指针区别
数组名对应的是指向数组首元素地址的指针，但该指针所指的地址不能被改写
对数组名使用sizeof，得到的是数组元素个数与元素类型字节数的乘积；而对指针使用sizeof得到的是指针类型的字节数

右值引用只能绑定到要销毁的对象
面向过程的编程，它最重要的特点是函数，通过 main 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的
C 语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域，C++ 用于应用层开发，用户界面开发等与操作系统打交道的领域。

C++ 对 C 的“增强”，表现在以下几个方面：类型检查更为严格。增加了面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。

得分点 面向对象和面向过程、重载、void、struct、函数参数默认值、内联函数、引用、动态内存分配、作用域 标准回答 C 语言和 C++ 语言的区别如下： 1. C 语言是面向过程的语言，而 C++ 支持面向对象，所以 C 语言自然没有面向对象的封装、继承、多态等特性，也不支持面向对象的一些语法； 2. C++ 支持函数重载，C 语言不支持； 3. C 程序中如果函数没有任何参数需要将参数定义为 void 以此来限定函数不可传递任何参数，如果不进行限定让参数表默认为空其意义是可以传递任何参数，在 C++ 中，不带参数的函数表示函数不能传递任何参数； 4. C 语言 struct 中不能有函数，而 C++ 语言 struct 中可以有函数； 5. C 语言函数参数不支持默认值，而 C++ 语言支持参数默认值； 6. C++ 语言支持内联函数，而 C 语言不支持； 7. C++ 语言支持引用，而 C 语言不支持； 8. C 语言采用 malloc 和 free 函数动态申请和释放内存，而 C++ 使用 new 和 delete 运算符； 9. C 语言中只有局部和全局两个作用域，而 C++ 中有局部、全局、类、名称空间作用域。