编译预处理：处理以 # 开头的指令；
编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；
汇编：将汇编代码 .s 翻译成机器指令 .o 文件(目标文件)；
链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。

静态链接：将程序调用的库一起打包到可执行文件中，这样执行时就不需要调用别的库了，速度快，
但是链接的时候可能同一个库链接了好几次，导致空间浪费，而且如果该库更新了的话，整个程序需要重新编译；
动态链接：是在程序执行时才载入引用的库，因此方便更新。
结论：静态库每一个执行程序都会拷贝一份引用的库，而动态库只需要在内存中拷贝一份，避免空间浪费在程序执行时，
动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间

C++ 内存管理
C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区
栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。
堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。
全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放
代码区（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里
以上存储区在内存中的分布是如下形式(从低地址到高地址)：
text 段 --> .data 段 --> .bss 段 --> 堆 --> unused --> 栈 --> env

分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。
栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。
申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。

全局变量、局部变量、静态全局变量、静态局部变量的区别
C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：
全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。

全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，
其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。
静态全局变量具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域

静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，
它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

静态存储区：全局变量，静态局部变量，静态全局变量。
栈：局部变量。

如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次

什么是单例模式
单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。
定义一个单例类：
私有化它的构造函数，以防止外界创建单例类的对象；
使用类的私有静态指针变量指向类的唯一实例；
使用一个公有的静态方法获取该实例。

C++中调用类的私有成员函数的方法就是，在该类中再声明定义一个公有成员函数

对象创建限制在堆或栈
静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;
动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；
然后，调用类的构造函数创建对象。例如：A *p = new A()
限制对象只能建立在堆上：
构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；
将析构函数设置为 protected
限制对象只能建立在栈上：
解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。

内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中,需要三点：
起始地址： 结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；
偏移量： 结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，
如有需要编译器会在成员之间加上填充字节 （internal padding）；
总大小： 结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，
如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。

进行内存对齐的原因：（主要是硬件设备方面的问题）
某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；
某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；
相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；
某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；
某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。

优点：
便于在不同的平台之间进行移植，有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；
提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。

类的大小是指类的实例化对象的大小，用 sizeof 对类型名操作时，结果是该类型的对象的大小
与普通成员变量有关，与成员函数和静态成员无关。
虚函数对类的大小有影响，是因为虚函数表指针的影响。
虚继承对类的大小有影响，是因为虚基表指针带来的影响。
空类的大小是一个特殊情况，空类的大小为 1，当用 new 来创建一个空类的对象时，保证不同对象的地址不同，空类也占用存储

菱形继承：a->b,a->c,b->d,c->d d就含有a的两个成员
虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。
使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则就会造成内存泄漏。
比如指针重新赋值造成泄露

防泄漏：
内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存
智能指针：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，以下三种：
共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。
独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。 move转移
弱指针weak_ptr需要共享指针shared_ptr才能创建。每当拥有该对象的最后一个共享指针失去其所有权时，任何弱指针weak_ptr都会自动变为空

循环引用 ：用弱指针解决
在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。

lib是链接时需要的，dll是运行时需要的。附加依赖项的是.lib不是.dll，若生成了DLL,则肯定也生成LIB文件
H文件作用是:声明函数接口                    DLL文件作用是: 函数可执行代码
当我们在自己的程序中引用了一个H文件里的函数,编链器怎么知道该调用哪个DLL文件呢?这就是LIB文件的作用: 
告诉链接器调用的函数在哪个DLL中，函数执行代码在DLL中的什么位置，这也就是为什么需要附加依赖项.LIB文件，它起到桥梁的作用。
如果生成静态库文件，则没有DLL ，只有lib，这时函数可执行代码部分也在lib文件中

静态类型和动态类型：
静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。
动态类型：目前所指对象的类型，是在运行阶段确定的。动态类型可以更改。
对于类的成员函数，只有虚函数是动态绑定，其他都是静态绑定。



