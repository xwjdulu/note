q1981:朴素思路：dfs每一行拿一个数进行组合：得到最接近target的数，o(n^m)不符和时间复杂度，那么能否加上记忆化

dp[i]表示每行下最接近target的数，不能！！！因为每个dfs的返回值不是确定答案，还要加上前面几行的值

正确思路：类似于背包问题；每一行里拿一个数，看看能组合成哪些价值,超时了：把下标读取换成引用！

优化：看看能组合成哪些小于target的数和一个大于等于target的数

对于优化：错误做法：用一个vector维护能组成哪些数：可能产生很多重复的数，虽然emplace_back()时间复杂度为$O(1)$

那用unordered_set可以吗，不可以

unordered_set 插入操作平均时间复杂度为$O(1)$,最差情况为$O(n)$.

注意：大于等于target的数numbig在每一行可能由两种方式产生：之前的numbig+x，之前的numsmall+x；
***


