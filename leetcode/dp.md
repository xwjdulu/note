除法取模出错 q2400题 恰好移动k步
1：乘法逆元
2：背包问题的递推
for(int i = 0;i<k+1;i++){
    vc[i][0] = 1;
    for(int j = 1;j<=i;j++){
        vc[i][j] = (vc[i-1][j-1]+vc[i-1][j])%mod;
    }
}
return vc[k][cap];

注意if(false) ret = max(ret,cur)
但遍历完也没有false

q788 数位dp
233. 数字 1 的个数（题解）
面试题 17.06. 2出现的次数（题解）
600. 不含连续1的非负整数（题解）
902. 最大为 N 的数字组合（视频讲解 中讲了）
1012. 至少有 1 位重复的数字（题解，包含 \textit{isNum}isNum 的用法）
1067. 范围内的数字计数
1397. 找到所有好字符串（有难度，需要结合一个知名字符串算法）
递归函数：
{
    当pos == len，判断该数是否满足条件(pos一般从高到低)
    int ret = 0;
    for(int i = 0;i<9/limit;i++){
    }
    return ret
}
状态多次出现：记忆化搜索，记忆化剪枝

01背包问题和完全背包问题的差别在于：01背包的每个物品只有一个，而完全背包有无限个。
在一维解法上，01背包是从右向左，而完全背包是从左向右。
01：
 s[i][j]=max(s[i][j],s[i-1][j-v[i]]+w[i]);
优化成一维：背包j应该从大到小
完全：
s[i][j]=max(s[i][j],s[i][j-v[i]]+w[i]);
优化成一维：背包j应该小到大

dp[i][j]:i表示天数，j表示几种状态

q795 计算一个数组中最大值不超过limit的子数组：
用cur记录当前满足条件长度：res+=cur
cur代表以当前元素结尾的子数组

动态规划和递归的相似处：把每一步的可能情况以空间存储起来
递归：记忆化，动态规划

字符串转化为回文串
dp[i][j] = dp[i+1][j-1]+s[i] == s[j]

q2463,q1478
状态值不是一个直观的值，可以是一个比较后的一定的优化值，把问题切分为同类型，
小规模的子问题，注意初始状态应该是0还是最值

dp[i][j]:习惯：i表示数组范围，j表示背包个数，审题，细节！
q2472,647:
        for(int i = 0;i<2*n-1;i++){
            int left = i/2,right = left+i%2;
            while(left>=0 && right<n && s[left] == s[right]){
枚举长度奇偶的回文串的开始中心

q1092 q1143 longest common subsequence  
用dp[i][j]表示两个字符串前i，j位能否构建出的序列值.
对于两个字符串问题，通常都要枚举每个字符并思考两者关系入手