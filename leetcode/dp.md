除法取模出错 q2400题 恰好移动k步
1：乘法逆元
2：背包问题的递推
for(int i = 0;i<k+1;i++){
    vc[i][0] = 1;
    for(int j = 1;j<=i;j++){
        vc[i][j] = (vc[i-1][j-1]+vc[i-1][j])%mod;
    }
}
return vc[k][cap];

注意if(false) ret = max(ret,cur)
但遍历完也没有false

q788 数位dp
233. 数字 1 的个数（题解）
面试题 17.06. 2出现的次数（题解）
600. 不含连续1的非负整数（题解）
902. 最大为 N 的数字组合（视频讲解 中讲了）
1012. 至少有 1 位重复的数字（题解，包含 \textit{isNum}isNum 的用法）
1067. 范围内的数字计数
1397. 找到所有好字符串（有难度，需要结合一个知名字符串算法）
递归函数：
{
    当pos == len，判断该数是否满足条件(pos一般从高到低)
    int ret = 0;
    for(int i = 0;i<9/limit;i++){
    }
    return ret
}
状态多次出现：记忆化搜索，记忆化剪枝

01背包问题和完全背包问题的差别在于：01背包的每个物品只有一个，而完全背包有无限个。
在一维解法上，01背包是从右向左，而完全背包是从左向右。
01：
 s[i][j]=max(s[i][j],s[i-1][j-v[i]]+w[i]);
优化成一维：背包j应该从大到小
完全：
s[i][j]=max(s[i][j],s[i][j-v[i]]+w[i]);
优化成一维：背包j应该小到大

