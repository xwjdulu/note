除法取模出错 q2400题 恰好移动k步
1：乘法逆元
2：背包问题的递推
for(int i = 0;i<k+1;i++){
    vc[i][0] = 1;
    for(int j = 1;j<=i;j++){
        vc[i][j] = (vc[i-1][j-1]+vc[i-1][j])%mod;
    }
}
return vc[k][cap];

注意if(false) ret = max(ret,cur)
但遍历完也没有false

q788 数位dp
233. 数字 1 的个数（题解）
面试题 17.06. 2出现的次数（题解）
600. 不含连续1的非负整数（题解）
902. 最大为 N 的数字组合（视频讲解 中讲了）
1012. 至少有 1 位重复的数字（题解，包含 \textit{isNum}isNum 的用法）
1067. 范围内的数字计数
1397. 找到所有好字符串（有难度，需要结合一个知名字符串算法）
递归函数：
{
    当pos == len，判断该数是否满足条件(pos一般从高到低)
    int ret = 0;
    for(int i = 0;i<9/limit;i++){
    }
    return ret
}
状态多次出现：记忆化搜索，记忆化剪枝

01背包问题和完全背包问题的差别在于：01背包的每个物品只有一个，而完全背包有无限个。
在一维解法上，01背包是从右向左，而完全背包是从左向右。
01：
 s[i][j]=max(s[i][j],s[i-1][j-v[i]]+w[i]);
优化成一维：背包j应该从大到小
完全：
s[i][j]=max(s[i][j],s[i][j-v[i]]+w[i]);
优化成一维：背包j应该小到大

dp[i][j]:i表示天数，j表示几种状态

q795 计算一个数组中最大值不超过limit的子数组：
用cur记录当前满足条件长度：res+=cur
cur代表以当前元素结尾的子数组

动态规划和递归的相似处：把每一步的可能情况以空间存储起来
递归：记忆化，动态规划

字符串转化为回文串
dp[i][j] = dp[i+1][j-1]+s[i] == s[j]

q2463,q1478
状态值不是一个直观的值，可以是一个比较后的一定的优化值，把问题切分为同类型，
小规模的子问题，注意初始状态应该是0还是最值

dp[i][j]:习惯：i表示数组范围，j表示背包个数，审题，细节！
q2472,647:
        for(int i = 0;i<2*n-1;i++){
            int left = i/2,right = left+i%2;
            while(left>=0 && right<n && s[left] == s[right]){
枚举长度奇偶的回文串的开始中心

q1092 q1143 longest common subsequence  
用dp[i][j]表示两个字符串前i，j位能否构建出的序列值.
对于两个字符串问题，通常都要枚举每个字符并思考两者关系入手

明确dp需要的各个参数
q673 q300
q718 类似两个字符串，比较两个数组里每一位，dp q115 unsigned long long
q132 注意动态规划里经常用序号，与下标，减一对应！
***
q583,除了直接dp，也可以先求出它们最长的公共子序列，dp[m+1][n+1]预留的位置相当于dfs的终止条件

qoffer60 dp        

q1638 dp方法：每一个不等的i,j组合，其产生的字符串对根据左右连续相等长判断
***
q2585：背包问题：初始化：得分为0，背包数x一般都是有1种方案，dp[i][j]表示前几个背包有j分

因为一个背包有score，那么dp[i][score] += dp[i-1][0]:当前背包得了score分
***
q1043:目标数组可以分为多个子数组，即当前状态减去一个子数组是之前状态：动态规划
***
q10:正则表达式

1：'*'表示前面的字符出现0次或多次！

2：'*'之前的字符看看能否和s[i-1]相匹配，可以的话s[i-1]可以删去继续匹配，否则只能删'*'组合

3：for(int i = 0;;)for(int j = 1)因为第一个s为空，p不为空可能产生匹配true,比如""和"a*"
***
q1696:对于dp问题，但是枚举dp来源耗费太多时间复杂度，在这个确定的思路上进行优化：

1，对当前的dp来源使用优先队列：每一个下标总有一个最大值，从堆里面找

2，每个下标的dp来源是滑动窗口：求滑动窗口里面的最大价值(单调队列)
***
q1039,q1000：大问题能转化为小区间问题加一个其它计算式

dp[l][r][c]表示将l到r合并为c个区间，则dp[r][l][1]：先合为k个，再合为一个

dp[l][r][c] = min(dp[l][x][1]+dp[x+1][r][c-1]);

以上思路来源为k==2，如果能两个区间合并为一个区间就简单了，那么我们先合并c-1个，再合并1个，求总共c个的最小成本
***
q1626:先排序，使后续的元素放入组合时满足某条件，对于同ages，判断不同的scores应该在前在后

将分数从小到大排序后，对于每个要放入的球员，其条件是其年龄比之前年龄都小(注意边界条件，一开始可能有没有前置球员)

dp[i] 就是i号球员加上低于其年龄里组合里最大的得分，可以用树状数组维护年龄段内的组合最大分(根据数据量选年龄)
***
q1981:朴素思路：dfs每一行拿一个数进行组合：得到最接近target的数，o(n^m)不符和时间复杂度，那么能否加上记忆化

dp[i]表示每行下最接近target的数，不能！！！因为每个dfs的返回值不是确定答案，还要加上前面几行的值

正确思路：类似于背包问题；每一行里拿一个数，看看能组合成哪些价值,超时了：把下标读取换成引用！

优化：看看能组合成哪些小于target的数和一个大于等于target的数
***
q823:dp问题：相乘记得转化数据类型！！
***
q1105,利用记忆化搜索寻找思路时，注意，每一层return时，子问题已经是确定的答案了
***
q2327：dp[i]表示第i天新知道秘密人数，之前某个区间内的秘密人数总和就是dp[i]

优化：区间和用一个前缀和数组求
***
不要申请过大空间的局部变量，局部变量都在栈上，堆栈溢出，会在调用函数时造成段错误




