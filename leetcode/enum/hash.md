滚动哈希：q1147，1044，28，187，718

预处理字符串，类似前缀和，得到$s_0-s_i$的字符串的哈希值，于是可以得到$s_i-s_j$的字串哈希值，o(1)时间判断两个字串是否相等

字母a ~ z用数字1 ~ 26来计算hashCode
我们利用一个数b，来作为base，一般b取131或1331等质数

对于单词apple：$$hashCode(apple) = 1 * pow(131, 0) + 16 * pow(131, 1) + 16 * pow(131, 2) + 12 * pow(131, 3) + 5 * pow(131, 4)$$

找到一个数p，每次求hashCode时，都需要对p取模,p是用来规避哈希冲突的，所以p要比较大

求hashcode数组(类似前缀和)
$$hash[i + 1] = (hash[i] * base + s.charAt(i) - 'a' + 1) % p$$

易得：
hashCode(l, r) = hash[r] - hash[l - 1] * pow(b, r - l + 1)

同时新建一个pow数组快速得base的各指数值

q1044:当字符串长度过长时：可能产生哈希冲突：不同的key产生相同的value,这个时候就创建两组哈希值，只有当两个字符串的两组哈希值都相等时，才认为字符串相等
***
q421   1,寻找数组中满足条件的两个数，但数据量要求单次遍历时，用哈希思想

2，i^j == x,要在哈希里找i，可以由 i == j^x 但x怎么得知呢

3, 从高位到低位，假设x某一位为1，如果能形成，则x该位置1，否则置0
***
q2488 边界条件要清晰

q209 1，滑动窗口 2，前缀和加二分查找

q76,两张哈希表，判断一个字符有没有在t出现过，直接对map找

q2080:对每个数的每个出现长度存放下标，对出现下标进行二分查找得到下标前出现次数，对mp[val]进行引用：auto &vc = mp[val]
***
q380 :哈希表加变化数组

q6537 根据数据量，不能记录每个数出现次数，然后看和query[i]差多少，o(m*n)

应该用o(nlogn)方法：对于每个query[i],比它小的nums步骤数是query[i]-nums,比它大的是nums-query[i]

***
q2302:低级思路：枚举每个右边界，找到区间值最接近小于k的左边界：1，通过二分查找得到左边界

2，滑动窗口维护左边界
***
q2609:n^2时间复杂度：去掉两端得更小区间；o(n)复杂度：长度=2*min(连续0个数,连续1个数)
